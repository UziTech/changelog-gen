#!/usr/bin/env node
;
var FIRST_COMMIT, GIT_FIRST_COMMIT, GIT_LAST_TAG_CMD, GIT_LOG_CMD, GIT_TAGS_CMD, HEAD, LAST_TAG, NONE, args, binPath, child, d, get_all_tags, get_end, get_first_commit, get_previous_tag, get_start, grep, node, option, options, path, q, read_git_log, util, _ref,
  __slice = [].slice;

child = require('child_process');

util = require('util');

GIT_LOG_CMD = 'git log %s -E --format=%s %s | cat';

GIT_LAST_TAG_CMD = 'git describe --tags --abbrev=0';

GIT_TAGS_CMD = 'git tag';

GIT_FIRST_COMMIT = 'git rev-list HEAD | tail -n 1';

get_all_tags = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_TAGS_CMD, function(code, stdout, stderr) {
    if (code) {
      return deferred.resolve([]);
    } else {
      return deferred.resolve(stdout.split('\n').filter(function(s) {
        return s.length !== 0;
      }));
    }
  });
  return deferred.promise;
};

get_previous_tag = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_LAST_TAG_CMD, function(code, stdout, stderr) {
    if (code) {
      return get_first_commit().then(function(commit) {
        return deferred.resolve(commit);
      });
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

get_first_commit = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_FIRST_COMMIT, function(code, stdout, stderr) {
    if (code) {
      return deferred.reject("Cannot get the first commit.");
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

read_git_log = function(grep, from, to) {
  var cmd, deferred, range;
  if (to == null) {
    to = 'HEAD';
  }
  deferred = q.defer();
  grep = grep != null ? "--grep=\"" + grep + "\"" : '';
  range = from != null ? "" + from + ".." + to : '';
  cmd = util.format(GIT_LOG_CMD, grep, '%H%n%s%n%b%n==END==', range);
  child.exec(cmd, function(code, stdout, stderr) {
    var commits;
    commits = [];
    stdout.split('\n==END==\n').forEach(function(rawCommit) {
      var commit;
      commit = rawCommit.split('\n').filter(function(s) {
        return s.length;
      }).join('\n');
      if (commit) {
        return commits.push(commit);
      }
    });
    return deferred.resolve(commits);
  });
  return deferred.promise;
};

q = require('qq');

path = require('path');

LAST_TAG = 'last-tag';

FIRST_COMMIT = 'first-commit';

HEAD = 'HEAD';

NONE = 'none';

options = {
  grep: '^Add|^Fix|^Remove|^:bug:|Breaking',
  start: LAST_TAG,
  end: HEAD
};

_ref = process.argv, node = _ref[0], binPath = _ref[1], args = 3 <= _ref.length ? __slice.call(_ref, 2) : [];

while (args.length) {
  option = args.shift();
  switch (option) {
    case '--grep':
      grep = args.shift();
      if (grep === NONE) {
        options.grep = null;
      } else {
        options.grep = grep;
      }
      break;
    case '--start':
      options.start = args.shift();
      break;
    case '--end':
      options.end = args.shift();
  }
}

get_start = options.start === FIRST_COMMIT ? get_first_commit() : options.start === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.start), d.promise);

get_end = options.end === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.end), d.promise);

get_start.then(function(from) {
  return get_end.then(function(to) {
    return read_git_log(options.grep, from, to).then(function(commits) {
      return console.log(commits);
    });
  });
});
