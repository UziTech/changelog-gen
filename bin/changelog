#!/usr/bin/env node
;
var COMMIT_URL, EXTERNAL_LINK_ISSUE, FIRST_COMMIT, GITHUB_URL, GIT_COMMIT_SEARCH, GIT_FIRST_COMMIT, GIT_LAST_TAG_CMD, GIT_LOG_CMD, GIT_TAGS_CMD, HEAD, HEADER_TPL, ISSUE_URL, LAST_TAG, LINK_COMMIT, LINK_ISSUE, NONE, PACKAGE_JSON, REPO_URL, all_tags, args, binPath, child, curate_sections, current_date, d, error, find_fixes, find_rev_index_for_commit, first_commit, get_all_tags, get_end, get_first_commit, get_previous_tag, get_start, get_tag_of_commit, grep, link_to_commit, link_to_issue, natural_sort, node, option, options, parse_raw_commit, path, print_section, print_sections, q, read_git_log, reverse_array, stream, string_or_url, util, warn, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

q = require('qq');

path = require('path');

child = require('child_process');

util = require('util');

natural_sort = require('javascript-natural-sort');

LAST_TAG = 'last-tag';

FIRST_COMMIT = 'TAIL';

HEAD = 'HEAD';

NONE = 'none';

GIT_LOG_CMD = 'git log %s -E --format=%s %s | cat';

GIT_LAST_TAG_CMD = 'git describe --tags --abbrev=0';

GIT_TAGS_CMD = 'git tag';

GIT_FIRST_COMMIT = 'git rev-list HEAD | tail -n 1';

GIT_COMMIT_SEARCH = 'git name-rev --name-only ';

options = {
  grep: '^Add|^Fix|^Remove|^:bug:|Breaking',
  start: LAST_TAG,
  end: HEAD
};

warn = function() {
  return console.log("WARNING:", util.format.apply(null, arguments));
};

error = function() {
  console.log("ERROR:", util.format.apply(null, arguments));
  return process.exit();
};

string_or_url = function(field) {
  if (typeof field === 'string') {
    return field;
  } else {
    return field != null ? field.url : void 0;
  }
};

PACKAGE_JSON = require(path.resolve('.', 'package.json'));

GITHUB_URL = 'https://github.com/';

REPO_URL = string_or_url(PACKAGE_JSON.repository);

ISSUE_URL = string_or_url(PACKAGE_JSON.bugs);

COMMIT_URL = string_or_url(PACKAGE_JSON.commits);

if (ISSUE_URL == null) {
  if ((REPO_URL != null) && REPO_URL.indexOf('http') === 0) {
    ISSUE_URL = REPO_URL + '/issues';
  } else {
    return error("Can't locate the `bugs` field in package.json");
  }
}

if (COMMIT_URL == null) {
  warn("Can't locate the `commits` field in package.json, building it using bugs url");
  COMMIT_URL = ISSUE_URL.replace('issues', 'commit');
}

HEADER_TPL = "<a name=\"%s\"></a>\n# %s (%s)\n\n";

LINK_ISSUE = "[#%s](" + ISSUE_URL + "/%s)";

EXTERNAL_LINK_ISSUE = "[#%s](" + GITHUB_URL + "/%s/%s)";

LINK_COMMIT = "[%s](" + COMMIT_URL + "/%s)";

stream = process.stdout;

find_rev_index_for_commit = function(commit, tags) {
  var deferred;
  deferred = q.defer();
  if (__indexOf.call(tags, commit) >= 0) {
    deferred.resolve(tags.indexOf(commit));
  } else {
    get_tag_of_commit(commit, tags).then(function(tag) {
      return deferred.resolve(tags.indexOf(tag) - 1);
    });
  }
  return deferred.promise;
};

get_tag_of_commit = function(sha, tags) {
  var cmd, deferred;
  cmd = GIT_COMMIT_SEARCH + sha;
  deferred = q.defer();
  child.exec(cmd, function(code, stdout, stderr) {
    var offset, res, tag, _ref;
    if (code) {
      return get_first_commit().then(function(commit) {
        return deferred.resolve(commit);
      });
    } else {
      res = stdout.replace('\n', '');
      _ref = res.split('~'), tag = _ref[0], offset = _ref[1];
      if (__indexOf.call(tags, tag) < 0) {
        tag = 'HEAD';
      }
      return deferred.resolve(tag);
    }
  });
  return deferred.promise;
};

get_all_tags = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_TAGS_CMD, function(code, stdout, stderr) {
    if (code) {
      return deferred.resolve([]);
    } else {
      return deferred.resolve(stdout.split('\n').filter(function(s) {
        return s.length !== 0;
      }));
    }
  });
  return deferred.promise;
};

get_previous_tag = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_LAST_TAG_CMD, function(code, stdout, stderr) {
    if (code) {
      return get_first_commit().then(function(commit) {
        return deferred.resolve(commit);
      });
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

get_first_commit = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_FIRST_COMMIT, function(code, stdout, stderr) {
    if (code) {
      return deferred.reject("Cannot get the first commit.");
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

read_git_log = function(grep, from, to) {
  var cmd, deferred, range;
  if (to == null) {
    to = 'HEAD';
  }
  deferred = q.defer();
  grep = grep != null ? "--grep=\"" + grep + "\"" : '';
  range = from != null ? "" + from + ".." + to : '';
  cmd = util.format(GIT_LOG_CMD, grep, '%H%n%s%n%b%n==END==', range);
  child.exec(cmd, function(code, stdout, stderr) {
    var commits;
    commits = [];
    stdout.split('\n==END==\n').forEach(function(rawCommit) {
      var commit;
      commit = rawCommit.split('\n').filter(function(s) {
        return s.length;
      }).join('\n');
      if (commit) {
        return commits.push(commit);
      }
    });
    return deferred.resolve(commits);
  });
  return deferred.promise;
};

reverse_array = function(array) {
  var a, o, _i, _len;
  a = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    o = array[_i];
    a.unshift(o);
  }
  return a;
};

link_to_issue = function(_arg) {
  var issue, repo;
  repo = _arg[0], issue = _arg[1];
  if (repo != null) {
    return util.format(EXTERNAL_LINK_ISSUE, issue, repo, issue);
  } else {
    return util.format(LINK_ISSUE, issue, issue);
  }
};

link_to_commit = function(hash) {
  return util.format(LINK_COMMIT, hash.substr(0, 8), hash);
};

current_date = function() {
  var now, pad;
  now = new Date();
  pad = function(i) {
    return ("0" + i).substr(-2);
  };
  return util.format("%d-%s-%s", now.getFullYear(), pad(now.getMonth() + 1), pad(now.getDate()));
};

find_fixes = function(line, msg) {
  var issue, issue_re, match, re, repo, _;
  issue_re = "([^\\s/]+/[^\\s#])?#(\\d+)";
  re = RegExp("(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\\s" + issue_re, "i");
  match = re.exec(line);
  if (match != null) {
    _ = match[0], repo = match[1], issue = match[2];
    msg.closes.push([repo, issue]);
  }
  return match == null;
};

parse_raw_commit = function(raw) {
  var lines, match, msg;
  if (raw == null) {
    return null;
  }
  lines = raw.split('\n');
  msg = {};
  msg.hash = lines.shift();
  msg.subject = lines.shift();
  msg.closes = [];
  lines = lines.filter(function(line) {
    return find_fixes(line, msg);
  });
  match = raw.match(/BREAKING CHANGE:([\s\S]*)/);
  if (match) {
    msg.breaking = match[1];
  }
  msg.body = lines.join("\n");
  return msg;
};

curate_sections = function(tags_steps) {
  return function(commits_groups) {
    var commit, commits, commits_per_tag, current_tag, i, parsed_commit, section, sections, tag, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    commits_per_tag = [];
    for (i = _i = 0, _len = commits_groups.length; _i < _len; i = ++_i) {
      commits = commits_groups[i];
      current_tag = tags_steps[i];
      if (current_tag === HEAD) {
        current_tag = void 0;
      }
      commits_per_tag.push([current_tag, commits]);
    }
    sections = [];
    _ref = reverse_array(commits_per_tag);
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      _ref1 = _ref[_j], tag = _ref1[0], commits = _ref1[1];
      if (commits.length === 0) {
        continue;
      }
      section = {
        tag: tag,
        commits: []
      };
      for (_k = 0, _len2 = commits.length; _k < _len2; _k++) {
        commit = commits[_k];
        parsed_commit = parse_raw_commit(commit);
        section.commits.push(parsed_commit);
      }
      sections.push(section);
    }
    return sections;
  };
};

print_section = function(section) {
  var breaking_commits, closes, commit, commit_body, l, _i, _j, _len, _len1, _ref;
  stream.write(util.format(HEADER_TPL, section.tag, section.tag, current_date()));
  stream.write('## Changes\n\n');
  _ref = section.commits;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    commit = _ref[_i];
    closes = commit.closes.map(link_to_issue).join(', ');
    if (closes.length > 0) {
      closes = ", " + closes;
    }
    commit_body = commit.body.length > 0 ? "<br>" + commit.body : '';
    l = "- " + commit.subject + " (" + (link_to_commit(commit.hash)) + closes + ")" + commit_body + "\n";
    stream.write(l);
  }
  breaking_commits = section.commits.filter(function(c) {
    return c.breaking != null;
  });
  if (breaking_commits.length) {
    stream.write('## Breaking\n\n');
    for (_j = 0, _len1 = breakin_commits.length; _j < _len1; _j++) {
      commit = breakin_commits[_j];
      stream.write(commit.breaking);
    }
  }
  return stream.write('\n');
};

print_sections = function(sections) {
  var section, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = sections.length; _i < _len; _i++) {
    section = sections[_i];
    _results.push(print_section(section));
  }
  return _results;
};

_ref = process.argv, node = _ref[0], binPath = _ref[1], args = 3 <= _ref.length ? __slice.call(_ref, 2) : [];

while (args.length) {
  option = args.shift();
  switch (option) {
    case '--grep':
      grep = args.shift();
      if (grep === NONE) {
        options.grep = null;
      } else {
        options.grep = grep;
      }
      break;
    case '--start':
      options.start = args.shift();
      break;
    case '--end':
      options.end = args.shift();
  }
}

first_commit = get_first_commit();

get_start = options.start === FIRST_COMMIT ? first_commit : options.start === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.start), d.promise);

get_end = options.end === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.end), d.promise);

all_tags = get_all_tags();

q.all([first_commit, all_tags, get_start, get_end]).then(function(_arg) {
  var first_sha, from, get_end_index, get_start_index, tags, to;
  first_sha = _arg[0], tags = _arg[1], from = _arg[2], to = _arg[3];
  tags = tags.sort(natural_sort);
  tags.unshift(first_sha);
  tags.push(HEAD);
  get_start_index = find_rev_index_for_commit(from, tags);
  get_end_index = find_rev_index_for_commit(to, tags);
  return q.all([get_start_index, get_end_index]).then(function(_arg1) {
    var end_index, from_tag, i, read_commits, start_index, tags_steps, to_tag, _i, _ref1;
    start_index = _arg1[0], end_index = _arg1[1];
    read_commits = [];
    tags_steps = [];
    if (end_index !== start_index) {
      for (i = _i = _ref1 = start_index + 1; _ref1 <= end_index ? _i <= end_index : _i >= end_index; i = _ref1 <= end_index ? ++_i : --_i) {
        from_tag = tags[i - 1];
        to_tag = tags[i];
        tags_steps.push(to_tag);
        read_commits.push(read_git_log(options.grep, from_tag, to_tag));
      }
    } else {
      to_tag = tags[start_index];
    }
    if (to_tag !== to) {
      read_commits.push(read_git_log(options.grep, to_tag, to));
    }
    return q.all(read_commits).then(curate_sections(tags_steps)).then(print_sections).fail(function(reason) {
      return console.log(reason);
    });
  });
});
