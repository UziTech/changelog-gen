#!/usr/bin/env node
;
var COMMIT_URL, FIRST_COMMIT, GIT_COMMIT_SEARCH, GIT_FIRST_COMMIT, GIT_LAST_TAG_CMD, GIT_LOG_CMD, GIT_TAGS_CMD, HEAD, HEADER_TPL, ISSUE_URL, LAST_TAG, LINK_COMMIT, LINK_ISSUE, NONE, PACKAGE_JSON, all_tags, args, binPath, child, d, error, find_rev_index_for_commit, first_commit, get_all_tags, get_end, get_first_commit, get_previous_tag, get_start, get_tag_of_commit, grep, node, option, options, path, q, read_git_log, string_or_url, util, warn, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

q = require('qq');

path = require('path');

child = require('child_process');

util = require('util');

LAST_TAG = 'last-tag';

FIRST_COMMIT = 'first-commit';

HEAD = 'HEAD';

NONE = 'none';

GIT_LOG_CMD = 'git log %s -E --format=%s %s | cat';

GIT_LAST_TAG_CMD = 'git describe --tags --abbrev=0';

GIT_TAGS_CMD = 'git tag';

GIT_FIRST_COMMIT = 'git rev-list HEAD | tail -n 1';

GIT_COMMIT_SEARCH = 'git name-rev --name-only ';

options = {
  grep: '^Add|^Fix|^Remove|^:bug:|Breaking',
  start: LAST_TAG,
  end: HEAD
};

warn = function() {
  return console.log("WARNING:", util.format.apply(null, arguments_));
};

error = function() {
  console.log("ERROR:", util.format.apply(null, arguments_));
  return process.exit();
};

string_or_url = function(field) {
  if (typeof field === 'string') {
    return field;
  } else {
    return field.url;
  }
};

PACKAGE_JSON = require(path.resolve('.', 'package.json'));

ISSUE_URL = string_or_url(PACKAGE_JSON.bugs);

COMMIT_URL = string_or_url(PACKAGE_JSON.commits);

if (ISSUE_URL == null) {
  return error("Can't locate the `bugs` field in package.json");
}

if (COMMIT_URL == null) {
  warn("Can't locate the `commits` field in package.json, building it using bugs url");
  COMMIT_URL = ISSUE_URL.replace('issues', 'commit');
}

HEADER_TPL = "<a name=\"%s\"></a>\n# %s (%s)\n\n";

LINK_ISSUE = "[#%s](" + ISSUE_URL + "/%s)";

LINK_COMMIT = "[%s](" + COMMIT_URL + "/%s)";

find_rev_index_for_commit = function(commit, tags) {
  var deferred;
  deferred = q.defer();
  if (__indexOf.call(tags, commit) >= 0) {
    deferred.resolve(tags.indexOf(commit));
  } else {
    get_tag_of_commit(commit, tags).then(function(tag) {
      return deferred.resolve(tags.indexOf(tag) - 1);
    });
  }
  return deferred.promise;
};

get_tag_of_commit = function(sha, tags) {
  var cmd, deferred;
  cmd = GIT_COMMIT_SEARCH + sha;
  deferred = q.defer();
  child.exec(cmd, function(code, stdout, stderr) {
    var offset, res, tag, _ref;
    if (code) {
      return get_first_commit().then(function(commit) {
        return deferred.resolve(commit);
      });
    } else {
      res = stdout.replace('\n', '');
      _ref = res.split('~'), tag = _ref[0], offset = _ref[1];
      if (__indexOf.call(tags, tag) < 0) {
        tag = 'HEAD';
      }
      return deferred.resolve(tag);
    }
  });
  return deferred.promise;
};

get_all_tags = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_TAGS_CMD, function(code, stdout, stderr) {
    if (code) {
      return deferred.resolve([]);
    } else {
      return deferred.resolve(stdout.split('\n').filter(function(s) {
        return s.length !== 0;
      }));
    }
  });
  return deferred.promise;
};

get_previous_tag = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_LAST_TAG_CMD, function(code, stdout, stderr) {
    if (code) {
      return get_first_commit().then(function(commit) {
        return deferred.resolve(commit);
      });
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

get_first_commit = function() {
  var deferred;
  deferred = q.defer();
  child.exec(GIT_FIRST_COMMIT, function(code, stdout, stderr) {
    if (code) {
      return deferred.reject("Cannot get the first commit.");
    } else {
      return deferred.resolve(stdout.replace('\n', ''));
    }
  });
  return deferred.promise;
};

read_git_log = function(grep, from, to) {
  var cmd, deferred, range;
  if (to == null) {
    to = 'HEAD';
  }
  deferred = q.defer();
  grep = grep != null ? "--grep=\"" + grep + "\"" : '';
  range = from != null ? "" + from + ".." + to : '';
  cmd = util.format(GIT_LOG_CMD, grep, '%H%n%s%n%b%n==END==', range);
  child.exec(cmd, function(code, stdout, stderr) {
    var commits;
    commits = [];
    stdout.split('\n==END==\n').forEach(function(rawCommit) {
      var commit;
      commit = rawCommit.split('\n').filter(function(s) {
        return s.length;
      }).join('\n');
      if (commit) {
        return commits.push(commit);
      }
    });
    return deferred.resolve(commits);
  });
  return deferred.promise;
};

_ref = process.argv, node = _ref[0], binPath = _ref[1], args = 3 <= _ref.length ? __slice.call(_ref, 2) : [];

while (args.length) {
  option = args.shift();
  switch (option) {
    case '--grep':
      grep = args.shift();
      if (grep === NONE) {
        options.grep = null;
      } else {
        options.grep = grep;
      }
      break;
    case '--start':
      options.start = args.shift();
      break;
    case '--end':
      options.end = args.shift();
  }
}

first_commit = get_first_commit();

get_start = options.start === FIRST_COMMIT ? first_commit : options.start === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.start), d.promise);

get_end = options.end === LAST_TAG ? get_previous_tag() : (d = q.defer(), d.resolve(options.end), d.promise);

all_tags = get_all_tags();

q.all([first_commit, all_tags, get_start, get_end]).then(function(_arg) {
  var first_sha, from, get_end_index, get_start_index, tags, to;
  first_sha = _arg[0], tags = _arg[1], from = _arg[2], to = _arg[3];
  tags.unshift(first_sha);
  tags.push(HEAD);
  get_start_index = find_rev_index_for_commit(from, tags);
  get_end_index = find_rev_index_for_commit(to, tags);
  return q.all([get_start_index, get_end_index]).then(function(_arg1) {
    var end_index, from_tag, i, read_commits, start_index, tags_steps, to_tag, _i, _ref1;
    start_index = _arg1[0], end_index = _arg1[1];
    read_commits = [];
    tags_steps = [];
    if (end_index !== start_index) {
      for (i = _i = _ref1 = start_index + 1; _ref1 <= end_index ? _i <= end_index : _i >= end_index; i = _ref1 <= end_index ? ++_i : --_i) {
        from_tag = tags[i - 1];
        to_tag = tags[i];
        tags_steps.push(to_tag);
        read_commits.push(read_git_log(options.grep, from_tag, to_tag));
      }
    } else {
      to_tag = tags[start_index];
    }
    if (to_tag !== to) {
      read_commits.push(read_git_log(options.grep, to_tag, to));
    }
    return q.all(read_commits).then(function(commits_groups) {
      var commits, commits_per_tag, current_tag, _j, _len;
      commits_per_tag = [];
      for (i = _j = 0, _len = commits_groups.length; _j < _len; i = ++_j) {
        commits = commits_groups[i];
        current_tag = tags_steps[i];
        if (current_tag === HEAD) {
          current_tag = void 0;
        }
        commits_per_tag.push([current_tag, commits]);
      }
      return console.log(commits_per_tag);
    });
  });
});
